#!/usr/bin/env python
import json
import os
import re
import subprocess
import sys

REPO_PATH = ""  # for debug purposes
PRH_CONFIG_PATH = "config_file_path"

sys.path.append(os.path.abspath(PRH_CONFIG_PATH))
import prh_config
import argparse

PRH_CONFIG_FILE_NAME = "/prh_config"
GIT_CONFIG_PATH = "/config"
GIT_FILE_PATH = "/.git"
APP_VERSION = "2.1.0"

DEFAULT_COMMIT_MESSAGE = ""  # prh_config.DEFAULT_COMMIT_MESSAGE
DEFAULT_PR_BODY = ""  # prh_config.DEFAULT_PULL_REQUEST_BODY
PIVOTAL_TRACKER_API_TOKEN = ""  # prh_config.PIVOTAL_TRACKER_API_TOKEN
GITHUB_API_TOKEN = ""
pivotal_tracker_story_id = ""
pivotal_tracker_story_url = ""
debug_is_on = 0
verbose_is_on = 0
local_only_is_on = 0
stay_is_on = 0
is_in_submodule = 0
repo_path = ""
pivotal_tracker_api_endpoint = "https://www.pivotaltracker.com/services/v5"
story = ""


class Service:
    import requests

    def __init__(self, token=False, header={}):
        self.token = token
        if token:
            self.header = {"X-TrackerToken": self.token}
        else:
            self.header = header

    def get(self, api):
        response = self.requests.get(api, headers=self.header)
        log("--> %s" % api)
        log("<-- %s\n" % response.json())
        return response

    def post(self, api, data):
        response = self.requests.post(api, data=data, headers=self.header)
        log("--> %s" % api)
        log("<-- %s\n" % response.json())
        return response

    def put(self, api, data):
        response = self.requests.put(api, data=data, headers=self.header)
        log("--> %s" % api)
        log("<-- %s\n" % response.json())
        return response

    @staticmethod
    def log(message):
        if verbose_is_on:
            print message


def log(message):
    if verbose_is_on:
        print message


def get_pivotal_story(story_id):
    global story
    if story:
        return story

    api = "{}/stories/{}".format(pivotal_tracker_api_endpoint, story_id)
    resp = Service(PIVOTAL_TRACKER_API_TOKEN).get(api)
    story = resp.json()
    return story


def get_pivotal_story_tasks(project_id, story_id):
    """
    [
      {
        "kind": "task",
        "id": 52555419,
        "story_id": 140104217,
        "description": "with some tasks",
        "complete": false,
        "position": 1,
        "created_at": "2017-02-16T23:52:05Z",
        "updated_at": "2017-02-16T23:52:05Z"
      },
      {
        "kind": "task",
        "id": 52555421,
        "story_id": 140104217,
        "description": "task 2",
        "complete": false,
        "position": 2,
        "created_at": "2017-02-16T23:52:09Z",
        "updated_at": "2017-02-16T23:52:09Z"
      }
    ]
    """
    api = "{}/projects/{}/stories/{}/tasks".format(pivotal_tracker_api_endpoint, project_id, story_id)
    resp = Service(PIVOTAL_TRACKER_API_TOKEN).get(api)
    return resp.json()


def mark_pivotal_story_finished(project_id, story_id):
    api = "{}/projects/{}/stories/{}".format(pivotal_tracker_api_endpoint, project_id, story_id)
    resp = Service(PIVOTAL_TRACKER_API_TOKEN).put(api, {"current_state": "finished"})
    return resp.json()


def post_pivotal_comment(project_id, story_id, text):
    api = "{}/projects/{}/stories/{}/comments".format(pivotal_tracker_api_endpoint, project_id, story_id)
    resp = Service(PIVOTAL_TRACKER_API_TOKEN).post(api, {"text": text})
    return resp.json()


def get_pivotal_project_id(story_id):
    global story
    if story:
        return story["project_id"]

    api = "{}/stories/{}".format(pivotal_tracker_api_endpoint, story_id)
    resp = Service(PIVOTAL_TRACKER_API_TOKEN).get(api)
    story = resp.json()
    return story["project_id"]


def finish_and_post_message_to_pivotal(story_id, message):
    project_id = get_pivotal_project_id(story_id)
    if not PIVOTAL_TRACKER_API_TOKEN:
        return 1
    if not mark_pivotal_story_finished(project_id, story_id):
        return 1
    if not post_pivotal_comment(project_id, story_id, message):
        return 1
    return 0


def run_command_str(command, output=0):
    command_list = str.split(command)
    run_command(command_list, output)


def run_command(command, output=0):
    """
    run the given command
    :param command:
    :param output:
    :return: 0 if no error occurs or the error code

    >>> run_command(["echo","hello world"],1)
    'hello world\\n'
    >>> run_command(["echo","hello world"])
    0
    >>> run_command(["ls","buchofjunck"],1)
    1
    >>> run_command(["ls","buchofjunck"],0)
    1
    """
    if debug_is_on:
        print_command(command)
        return 0
    else:
        if verbose_is_on:
            print command
        try:
            if output:
                run_output = subprocess.check_output(command)
            else:
                run_output = subprocess.check_call(command)

            log("\nOUTPUT:\t" + str(run_output))
            return run_output
        except subprocess.CalledProcessError as e:
            return e.returncode


def print_command(command):
    print get_head() + " >>> " + reduce(lambda x, y: x + " " + y, command)


def checkout(branch_name):
    command = ["git", "checkout", branch_name]
    run_command(command)


def add_files(file_paths):
    command = ["git", "add"] + file_paths
    return run_command(command, 1)


def add_all():
    command = ["git", "add", "-A"]
    return run_command(command, 1)


def get_head():
    # read the head from git dir
    with open(get_repo_git_dir() + "/HEAD") as f:
        ref = f.read()
        return ref.split("/")[-1].strip()


def get_repo_git_dir():
    git_config_dir_path = repo_path + GIT_FILE_PATH
    if os.path.isfile(git_config_dir_path):
        with open(git_config_dir_path) as f:
            line = f.readline()
            # gitdir: ../.git/modules/dxCore
            git_dir_path = line.split(":")[1].strip()
            git_config_dir_path = repo_path + "/" + git_dir_path
            log(git_config_dir_path)

    return git_config_dir_path


def get_submodule_name():
    command = ["git", "submodule"]
    output = run_command(command, True)
    return output.split(" ")[1]


def get_status():
    return subprocess.check_output(["git", "status"])


def launch_browser(url):
    command = ["open", url if url else ""]
    run_command(command)


def cd(path):
    command = ["cd", path]
    run_command(command)


def ask_user(question):
    answer = raw_input(question)
    return str.lower(answer) == 'y'


def add_changes(is_add_all, file_paths):
    if is_add_all:
        error = add_all()
    elif file_paths:
        error = add_files(file_paths)
    else:
        error = "Failed to add files"

    return error


def delete_branch(branch_name):
    command = ["git", "branch", "-D", branch_name]
    res = run_command(command, 1)
    return res


def create_branch(branch_name):
    command = ["git", "checkout", "-q", "-b", branch_name]
    res = run_command(command, 0)
    if res == 128:
        answer = raw_input(">>> Branch already exists, would you like me to delete it (y/n)? ")
        if str.lower(answer) == 'y':
            delete_branch(branch_name)
            return create_branch(branch_name)
        else:
            return "Failed to create the new branch"
    else:
        return res


def commit(commit_message=DEFAULT_COMMIT_MESSAGE):
    if not commit_message:
        if pivotal_tracker_story_id:
            story_json = get_pivotal_story(pivotal_tracker_story_id)
            commit_message = story_json["name"]
        else:
            commit_message = DEFAULT_COMMIT_MESSAGE

    command = ["git", "commit", "-m", commit_message]
    res = run_command(command)
    if res:
        return "Failed to commit changes"


def push(branch_name):
    if local_only_is_on:
        return 0

    command = ["git", "push", "--set-upstream", "origin", branch_name]
    res = run_command(command)
    if res:
        return "Failed to push the commit to origin"


def find_existing_pr(owner, repo, head, base):
    api = "https://api.github.com/repos/{}/{}/pulls".format(owner, repo)
    res = github_api_get(api)
    if res.status_code < 300:
        matching_pr_list = [a for a in res.json()[:] if a["head"]["ref"] == head and a["base"]["ref"] == base]
        if matching_pr_list:
            return matching_pr_list[0]["html_url"]


def create_pull_request(from_branch, to_branch, pr_title, pr_body):
    if local_only_is_on:
        return 0

    if not pr_title:
        pr_title = get_head().replace("_", " ")
    if not pr_body:
        pr_body = DEFAULT_PR_BODY
    else:
        pr_body = pr_body + "\n" + DEFAULT_PR_BODY

    if pivotal_tracker_story_url:
        story = get_pivotal_story(pivotal_tracker_story_id)
        if "description" in story:
            description = story["description"]
        if "name" in story:
            name = story["name"]
        pr_body = pr_body + "\n\n**Story:** [" + name + "](" + pivotal_tracker_story_url + ")\n" + description

    setup_config_dic = read_from_setup_file()
    owner = setup_config_dic["owner"]
    repo = setup_config_dic["repo"]
    if not owner:
        print "run prh setup first"
        return 1

    # https://developer.github.com/v3/pulls/#create-a-pull-request
    github = "https://api.github.com"
    api = "{}/repos/{}/{}/pulls".format(github, owner, repo)
    data = {
        "title": pr_title,
        "body": pr_body,
        "head": from_branch,
        "base": to_branch
    }
    res = github_api_post(api, data)

    if res.status_code == 201:
        pr_url = res.json()["html_url"]
        print "PR created: {}".format(pr_url)
        if pr_url and str(pr_url)[:4] == "http":
            launch_browser(pr_url)
            if pivotal_tracker_story_id:
                if finish_and_post_message_to_pivotal(pivotal_tracker_story_id, "PR: " + pr_url):
                    print "error with pivotal"
        return 0
    else:
        existing_pr_url = find_existing_pr(owner, repo, from_branch, to_branch)
        if existing_pr_url:
            print existing_pr_url
            launch_browser(existing_pr_url)
            return 0

        for e in res.json()["errors"]:
            print "Error:", e["message"]
        return "Failed to create pull-request from " + from_branch + " to " + to_branch


def github_api_post(api, data):
    headers = {"Authorization": "token " + GITHUB_API_TOKEN}
    response = requests.post(api, data=json.dumps(data), headers=headers)
    log("--> %s" % api)
    log("<-- %s\n" % response.json())
    return response


def github_api_get(api):
    headers = {"Authorization": "token " + GITHUB_API_TOKEN}
    response = requests.post(api, headers=headers)
    log("--> %s" % api)
    log("<-- %s\n" % response.json())
    return response


def verify_file_paths(file_paths):
    # verify all the provided file paths are valid
    if file_paths:
        for p in file_paths:
            if not os.path.exists(p):
                print "Make sure %s exists" % p
                return 1


def verify_parent_in_origin(origin):
    if not os.path.exists(".git/refs/remotes/origin/%s" % origin):
        print "Push the parent branch '%s' to origin before using PRH" % origin
        return 1


def terminate_on_error(func, args):
    error = func(args)
    if error:
        return error


def process_from_child(origin, new, add_all, just_pr, file_paths, commit_message, pr_title, pr_body):
    return create_branch(new) \
           or (not just_pr and add_changes(add_all, file_paths)) \
           or (not just_pr and commit(commit_message)) \
           or push(new) \
           or create_pull_request(new, origin, pr_title, pr_body) \
           or (stay_is_on and checkout(origin)) \
           or "Done"


def process_to_parent(origin, parent, add_all, just_pr, file_paths, commit_message, pr_title, pr_body):
    return (not just_pr and add_changes(add_all, file_paths)) \
           or (not just_pr and commit(commit_message)) \
           or push(origin) \
           or create_pull_request(origin, parent, pr_title, pr_body) \
           or "Done"


def revert_all(branch_origin, branch_child, branch_parent, is_add_all, file_paths):
    if checkout(branch_origin):
        return "Failed to check out original branch"


def main(args):
    # there is a syntax error in arguments
    if not args:
        return False

    file_paths = []
    branch_child = branch_parent = pr_title = pr_body = is_add_all = is_just_pr = commit_message = ""
    need_to_confirm_empty = need_to_confirm_add_all = ""
    # get main branch name
    branch_origin = get_head()

    if args.setup:
        setup()
        return

    if args.debug:
        global debug_is_on
        debug_is_on = 1

    if args.verbose:
        global verbose_is_on
        verbose_is_on = 1

    if args.stay_on:
        global stay_is_on
        stay_is_on = 1

    if args.branch:
        branch_child = args.branch

    if args.sub_branch:
        branch_child = branch_origin + "_" + args.sub_branch

    if args.pr_body:
        pr_body = args.pr_body

    if args.pr_title:
        pr_title = args.pr_title

    if args.add:
        # -a exists
        for p in args.add:
            file_paths.append(p)

        # no path to add
        if not file_paths:
            need_to_confirm_empty = 1
    else:
        # no -a
        need_to_confirm_add_all = 1

    if args.empty:
        is_just_pr = True
        is_add_all = False
        need_to_confirm_add_all = False

    if args.upto:
        branch_parent = args.upto

    if args.sub:
        setup_file = read_from_setup_file()
        for pair in setup_file["submodules"]:
            if os.path.exists(pair):
                cd(pair)
                submodule_args = args
                submodule_args["sub"] = 0
                main(submodule_args)

    if args.message:
        commit_message = args.message
        re_search = re.search("http[s]?:\/\/.*pivotaltracker.*/(\d*)", commit_message)

        if re_search:
            full_url = re_search.group(0)
            story_id = re_search.group(1)
            global pivotal_tracker_story_id
            pivotal_tracker_story_id = story_id
            global pivotal_tracker_story_url
            pivotal_tracker_story_url = full_url
            commit_message = commit_message.replace(full_url, "")

    if args.local:
        global local_only_is_on
        local_only_is_on = 1

    # Verification

    error = verify_file_paths(file_paths)
    if error:
        return error

    error = verify_parent_in_origin(branch_origin)
    if error:
        return error

    if need_to_confirm_add_all:
        list_of_changes = str(run_command(["git", "add", "-A", "-n"], 1)).strip()
        if not list_of_changes:
            # list of changes is empty
            need_to_confirm_empty = True
        else:
            print("\n" + list_of_changes)
            if ask_user(">>> Would you like to apply above changes (y/n)? "):
                is_add_all = True
            else:
                return "Either add files using -a or add all the changes"

    if need_to_confirm_empty:
        if ask_user(">>> No file has been added, would you like to continue creating PR (y/n)? "):
            is_just_pr = True
        else:
            return "Either add files using -a or add all the changes"

    if branch_child and not branch_parent:
        print process_from_child(branch_origin, branch_child, is_add_all, is_just_pr, file_paths, commit_message,
                                 pr_title, pr_body)
    elif branch_parent and not branch_child:
        print process_to_parent(branch_origin, branch_parent, is_add_all, is_just_pr, file_paths, commit_message,
                                pr_title, pr_body)
    else:
        return


def setup():
    setup_config = read_from_setup_file()
    if setup_config:
        return 0

    print "Running setup"
    remotes = []

    git_dir = get_repo_git_dir()
    if os.path.isdir(git_dir):
        with open(git_dir + GIT_CONFIG_PATH) as git_config:
            config_string = git_config.read()
            remotes = re.findall('\[remote "(.*)"\].*\n.*url = (git.*\.git).*', config_string)
            # submodules = re.findall('\[submodule "(.*)"\]\n.*url = (.*).*', config_string)
    else:
        print "You should run prh from a git repository directory"
        return

    if not remotes:
        print "Could not find origin url in the .git/config file"
        return

    write_to_setup_file(remotes)


def run_popen(command):
    popen = subprocess.Popen(command, stdin=subprocess.PIPE, shell=True, stdout=subprocess.PIPE)
    with popen.stdout as output:
        return output.readline().replace("\n", "")
    return '.'


def get_owner(git_url):
    """
    >>> get_owner("git@github.com:doximity/Android.git")
    'doximity'
    """
    return git_url.split(":")[-1].split("/")[0]


def get_repo(git_url):
    """
    >>> get_repo("git@github.com:doximity/Android.git")
    'Android'
    """
    return git_url.split(":")[-1].split("/")[1].split(".")[0]


def write_to_setup_file(remotes):
    # git@github.com:doximity/Android.git
    index = 1
    selected_remote_index = '1'
    if len(remotes) > 2:
        for i, j in remotes:
            print "%d : %s = %s" % (index, i, j)
            index += 1
        selected_remote_index = raw_input("Which remote to use (enter line number)?")

    owner = get_owner(remotes[int(selected_remote_index) - 1][1])
    repo = get_repo(remotes[int(selected_remote_index) - 1][1])

    submodules_dic = {}
    # for submodule in submodules:
    #     submodules_dic[submodule[0]] = submodule[1]

    # command = ["git rev-parse --show-toplevel"]
    # repo_root_path = run_popen(command)
    out = json.dumps({"owner": owner, "repo": repo, "submodules": submodules_dic})
    with open(repo_path + '/.prh', 'w') as f:
        f.write(out)


def read_from_setup_file():
    """
    Read the REPO Scoped config file of PRH
    :return:
    """
    if os.path.exists(repo_path + '/.prh'):
        with open(repo_path + '/.prh', 'r') as f:
            return json.load(f)


def parse_arguments():
    parser = argparse.ArgumentParser(
        description="You can use prh in two main ways:<br>\n1) create a pr from a new branch to current branch\n"
                    "prh -b <child_branch_name> [-a <file1_path> <file2_path> ...]\n"
                    "2) create a pr from current branch to a different branch\n"
                    "prh -upto <parent_branch_name>\n", version=APP_VERSION)
    parser.add_argument("--verbose", help="run in verbose mode", const=True, nargs='?')
    parser.add_argument("-d", "--debug", help="run in debug mode", const=True, nargs='?')
    parser.add_argument("-s", "--stay_on", help="come back to current branch after all is done", const=True, nargs='?')
    parser.add_argument("-b", "--branch", help="Name of child branch", nargs='?')
    parser.add_argument("-sb", "--sub_branch", help="Name of child branch appended to the name of parent branch",
                        nargs='?')
    parser.add_argument("-pb", "--pr_body", help="Overwrite PullRequest Body text", nargs='?')
    parser.add_argument("-pt", "--pr_title", help="OverWrite PullRequest Title text", nargs='?')
    parser.add_argument("-a", "--add",
                        help="Add files with given path, not using the option will add all files",
                        nargs='*')
    parser.add_argument("-e", "--empty",
                        help="not making any commits or adds, just creates the PR",
                        const=True,
                        nargs='?')
    parser.add_argument("-upto", "--upto", help="Name of the parent branch that this PR should point to", nargs='?')
    parser.add_argument("-sub", "--sub", help="", const=True, nargs='?')
    parser.add_argument("-m", "--message",
                        help="Overwrite commit message or add a Pivotal Tracker "
                             "story link to fetch all the details from the story",
                        nargs='?')
    parser.add_argument("-l", "--local",
                        help="Do not push any changes or create a PR, only create the branch and make the commit",
                        const=True, nargs='?')
    parser.add_argument("setup", help="Setup the pull-request helper", const=True, nargs='?')

    args = parser.parse_args()

    if not args.branch and not args.upto and not args.sub_branch and not args.setup:
        parser.print_help()
        return False

    return args


def write_to_config_file(dic):
    """
    write to the user scoped config file for PRH
    :param dic:
    :return:
    """
    with open(PRH_CONFIG_PATH + PRH_CONFIG_FILE_NAME + ".py", mode='w') as f:
        for key in dic:
            f.write(key + "=\"" + dic[key] + "\"\n")


if __name__ == "__main__":
    DEFAULT_COMMIT_MESSAGE = prh_config.DEFAULT_COMMIT_MESSAGE
    DEFAULT_PR_BODY = prh_config.DEFAULT_PULL_REQUEST_BODY
    PIVOTAL_TRACKER_API_TOKEN = prh_config.PIVOTAL_TRACKER_API_TOKEN
    GITHUB_API_TOKEN = prh_config.GITHUB_API_TOKEN

    if REPO_PATH:
        repo_path = REPO_PATH
    else:
        # get current working dir
        repo_path = os.getcwd()

    setup_config = read_from_setup_file()
    if not setup_config:
        setup()

    config_changed = 0
    if not GITHUB_API_TOKEN:
        config_changed = 1
        GITHUB_API_TOKEN = raw_input("Please enter your Github API token: ")
    if not PIVOTAL_TRACKER_API_TOKEN:
        config_changed = 1
        PIVOTAL_TRACKER_API_TOKEN = raw_input("Please enter your PivotalTracker API token: ")

    if config_changed:
        write_to_config_file({
            "GITHUB_API_TOKEN": GITHUB_API_TOKEN,
            "PIVOTAL_TRACKER_API_TOKEN": PIVOTAL_TRACKER_API_TOKEN,
            "DEFAULT_COMMIT_MESSAGE": "Commit",
            "DEFAULT_PULL_REQUEST_BODY": "",
            "SLACK_INTEGRATION_URL": ""
        })

    sys.exit(main(parse_arguments()))
